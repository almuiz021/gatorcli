# GatorDoc

A teaching-focused architecture guide for the Go CLI project using SQLC and Goose.

---

## 1. Project Overview

- **Purpose of the CLI**
  - Manage users in a Postgres-backed system via a simple command-line interface. Current feature set:
    - `register <username>`: Create a new user and set it as the current user in a local config file.
    - `login <username>`: Validate an existing user and set it as the current user.

- **High-level summary**
  - The program reads configuration from `~/.gatorconfig.json` to obtain the database URL and the current user.
  - It connects to PostgreSQL, initializes SQLC query bindings, parses the command and args from `os.Args`, and dispatches to the appropriate handler.
  - Handlers use SQLC-generated functions to read/write users and update the config file.
  - Database schema evolution is managed externally via Goose migrations.

---

## 2. Architecture Overview

- **Folder structure and roles**
  - **`main.go`**
    - Program entrypoint. Reads config, opens DB, wires SQLC `Queries`, configures command router, parses CLI args, and runs the selected command.
  - **`commands.go`**
    - Minimal command router with a `commands` registry. Maps command names to handler functions and runs them.
  - **`handler_user.go`**
    - Implements user-related handlers:
      - `handlerRegister`: Creates a user via SQLC and sets it as current in config.
      - `handlerLogin`: Fetches a user via SQLC and sets it as current in config.
  - **`internal/config`**
    - `config.go`: Defines `Config` (fields: `DbURL`, `CurrentUserName`). Reads `~/.gatorconfig.json`, writes updates, and provides `SetUser`.
    - `configFileName.go`: Centralizes the config filename (`.gatorconfig.json`).
  - **`internal/database`** (generated by SQLC)
    - `db.go`: Core SQLC scaffolding for `Queries` and `New()` constructor.
    - `models.go`: SQLC model types (e.g., `User`).
    - `users.sql.go`: SQLC-generated methods for queries defined in `sql/queries/users.sql` (`CreateUser`, `GetUser`).
  - **`sql/`**
    - `schema/001_users.sql`: Goose-style migration that creates the `users` table.
    - `queries/users.sql`: Query definitions that SQLC reads to generate Go methods.
  - **`sqlc.yaml`**
    - SQLC configuration mapping schema and query directories to the Go package output (`internal/database`).
  - **`gooser.sh`**
    - Convenience script to set Goose environment variables for running migrations.
  - **`go.mod`, `go.sum`**
    - Module definition and dependencies (`github.com/lib/pq`, `github.com/google/uuid`).

- **How SQLC and Goose integrate**
  - Goose manages DDL migrations in `sql/schema` as versioned files with `-- +goose Up/Down` directives. Migrations are applied outside the app using the Goose CLI or scripts.
  - SQLC reads the final schema plus query files in `sql/queries` and generates type-safe Go code in `internal/database`. The application imports and calls these generated functions.

- **Data and command flow**
  - main → commands → handlers → database (SQLC) → PostgreSQL
  - Configuration is loaded early and used to connect to the DB; handlers may update the config (e.g., `SetUser`).

---

## 3. Execution Flow

- **Step-by-step runtime flow**
  1. Program starts at `main.go`.
  2. `config.Read()` loads `~/.gatorconfig.json` into a `Config` struct.
  3. `sql.Open("postgres", cfg.DbURL)` calls `database/sql` to create a DB handle using the `"postgres"` driver registered by `lib/pq` (real connections open lazily on first use).
  4. `database.New(db)` creates a SQLC `Queries` instance to access generated methods.
  5. Command registry is created and handlers are registered for `login` and `register`.
  6. CLI args are parsed from `os.Args` into a `command` (`Name`, `Args`).
  7. The command is dispatched via `cmds.run(state, command)`.
  8. The handler executes SQLC queries, applies any business logic, prints output, and may update config via `cfg.SetUser` (which writes to `~/.gatorconfig.json`).

- **How config is read**
  - `internal/config/config.go`:
    - `Read()` determines the home dir with `os.UserHomeDir()`, then reads `~/.gatorconfig.json`.
    - The file is unmarshaled into `Config` with fields `db_url` and `current_user_name`.
    - `SetUser()` updates `CurrentUserName` and writes the file back to the same location.

- **DB setup and SQLC usage**
  - The SQL connection string is taken from `cfg.DbURL`.
  - An instance of `database.Queries` is created once and stored in the app `state`.
  - Handlers call generated methods like `GetUser(ctx, name)` and `CreateUser(ctx, params)`.

- **Migrations and queries together**
  - Goose applies `sql/schema/001_users.sql` to create the `users` table before the CLI runs against the DB.
  - SQLC code assumes the schema exists; if migrations weren’t applied, SQL operations will fail.

---

## 4. Tooling Details

- **What SQLC generates**
  - From `sqlc.yaml`:
    - Reads `sql/schema` and `sql/queries` using engine `postgresql`.
    - Outputs Go code to `internal/database`.
  - Generated artifacts include:
    - `db.go`: `Queries` type, `New(db)` constructor, `WithTx` support.
    - `models.go`: Go structs for tables (e.g., `User`).
    - `users.sql.go`: Methods for each named query, e.g.:
      - `CreateUser(ctx context.Context, arg CreateUserParams) (User, error)`
      - `GetUser(ctx context.Context, name string) (User, error)`

- **How it’s used in handlers**
  - `handler_user.go`:
    - `handlerRegister` builds `CreateUserParams` (uuid, timestamps, name) and calls `CreateUser`.
    - `handlerLogin` calls `GetUser` by name and verifies existence.

- **How Goose migrations are structured and applied**
  - Migration file format with Goose markers:
    - `-- +goose Up` / `-- +goose Down` sections.
    - Example: `sql/schema/001_users.sql` creates the `users` table.
  - Applied using Goose CLI, e.g. with environment variables set by `gooser.sh`:
    - `GOOSE_DRIVER=postgres`
    - `GOOSE_DBSTRING=postgres://postgres:postgres@localhost:5432/gator`
  - Typical commands (run outside the app):
    - `goose -dir sql/schema up`
    - `goose -dir sql/schema down`

---

## 4a. Main Database Flow and Responsibilities (Who does what, where it happens)

- **database/sql (standard library)**
  - **Role**: Connection pooling, statement execution, query APIs. It’s the abstraction layer the app code talks to.
  - **Where used**: `main.go`
    - Creates the DB handle: `db, err := sql.Open("postgres", cfg.DbURL)`.
    - Manages connections lazily and pools them transparently.

- **lib/pq (Postgres driver)**
  - **Role**: Implements the `database/sql` driver for PostgreSQL and registers itself under the name `"postgres"`.
  - **Where used**: `main.go`
    - Imported for side effects: `_ "github.com/lib/pq"` so that `database/sql` can find the `"postgres"` driver when you call `sql.Open`.

- **SQLC (code generator)**
  - **Role**: Generates type-safe Go wrappers for SQL queries and models based on `sql/queries/*.sql` and the schema.
  - **Where used**:
    - Generated package: `internal/database` containing `New(*sql.DB) *Queries`, models (e.g., `User`), and methods like `CreateUser`, `GetUser`.
    - In code:
      - `main.go`: `dbQueries := database.New(db)` wires the `*sql.DB` (from `database/sql`) into SQLC’s `Queries`.
      - `handler_user.go`: Calls `s.db.GetUser(ctx, name)` and `s.db.CreateUser(ctx, params)`.

- **Goose (migrations)**
  - **Role**: Applies schema changes (DDL) in order. Not called by the app; run externally before the app uses the DB.
  - **Where used**:
    - Files: `sql/schema/001_users.sql` with `-- +goose Up/Down`.
    - Script: `gooser.sh` sets `GOOSE_DRIVER` and `GOOSE_DBSTRING` for CLI use.

- **End-to-end DB flow (put together)**
  1. Dev runs Goose migrations to create/update tables (e.g., `users`).
  2. App starts; `main.go` reads `cfg.DbURL` and calls `sql.Open("postgres", ...)`.
  3. `database/sql` uses the `lib/pq` driver (registered via blank import) to talk to Postgres.
  4. `database.New(db)` creates SQLC `Queries` bound to that DB handle.
  5. A handler (e.g., `handlerRegister`) executes a generated method (`CreateUser`).
  6. SQLC composes the SQL string and arguments, then calls into `database/sql` which executes against Postgres via `lib/pq`.
  7. Results are scanned into SQLC-generated models (e.g., `database.User`) and returned to the handler.

> In short: Handlers -> SQLC methods -> database/sql -> lib/pq driver -> Postgres.

## 5. Design Philosophy

- **Go idioms and structure**
  - Clear separation of concerns:
    - Entrypoint (`main.go`) handles wiring and bootstrapping.
    - Command routing decoupled via a simple registry (`commands.go`).
    - Business logic encapsulated in handlers (`handler_user.go`).
    - Configuration logic isolated (`internal/config`).
    - Data access is type-safe and generated (`internal/database` via SQLC).
  - Prefer composition over frameworks for a small CLI.
  - Keep generated code in `internal/` to avoid exporting it as a library.

- **Key takeaways for beginners**
  - Keep your `main` thin; wire dependencies and delegate work.
  - Use generated clients (SQLC) for safe, maintainable DB access.
  - Isolate mutations (e.g., config writes) behind small methods (`SetUser`).
  - Use migrations (Goose) to version and evolve your schema consistently.
  - Keep commands small and focused; add new commands by registering a new handler.

---

## 5a. Dependency Injection in this Project

- **What is Dependency Injection (DI)?**
  - A design technique where components receive (are injected) the dependencies they need rather than creating or looking them up globally. This improves testability, modularity, and clarity.

- **Why use DI here?**
  - Handlers need access to configuration and database queries. By injecting them, handlers are pure functions of inputs and easier to test (no hidden globals). Swapping implementations (e.g., mock DB) is trivial.

- **How DI is implemented (the `state` pattern)**
  - **The dependency container**: `type state struct { db *database.Queries; cfg *config.Config }` (in `main.go`).
  - **Construction (composition root)**: in `main.go` the program builds the dependencies once and assembles `state`:
    - Reads config: `cfg, _ := config.Read()`.
    - Opens DB: `db, _ := sql.Open("postgres", cfg.DbURL)`.
    - Wraps with SQLC: `dbQueries := database.New(db)`.
    - Assembles: `programState := &state{ cfg: &cfg, db: dbQueries }`.
  - **Injection point**: handlers are defined to accept `*state` explicitly:
    - Signature: `func handlerRegister(s *state, cmd command) error`
    - Signature: `func handlerLogin(s *state, cmd command) error`
  - **Call path**:
    - `main.go` registers handlers in `commands` and calls `cmds.run(programState, command{Name, Args})`.
    - `commands.run` looks up the handler and invokes it as `handler(programState, cmd)`.

  - There are **no package-level variables** holding `*database.Queries` or `*config.Config` in `handler_user.go` or elsewhere.
  - Handlers do not import or construct a DB; they use `s.db` and `s.cfg` provided by the caller.
  - Replacing dependencies is easy: in tests, build a fake `state` with a mock `*database.Queries` or stub methods and pass it to handlers.

> Summary: `state` is the injected dependency container. It is constructed in `main.go` (composition root) and passed down to handler functions, avoiding global state and enabling testability and clear ownership of resources.

## 6. Flow Diagrams (Mermaid)

- **Runtime flow**

```mermaid
flowchart TD
    A[Start: main.go] --> B[config.Read() -> ~/.gatorconfig.json]
    B --> C[sql.Open(cfg.DbURL) -> *sql.DB]
    C --> D[database.New(db) -> *Queries]
    D --> E[Build commands registry]
    E --> F[Parse os.Args -> command]
    F --> G[cmds.run(state, command)]
    G --> H{command.Name}
    H -->|register| I[handlerRegister]
    H -->|login| J[handlerLogin]
    I --> K[SQLC CreateUser]
    J --> L[SQLC GetUser]
    K --> M[config.SetUser]
    L --> M[config.SetUser]
    M --> N[Print result]
    N --> O[Exit]
```

- **Data/tooling flow**

```mermaid
flowchart LR
    subgraph Dev
      Q[sql/queries/*.sql]
      S[schema/*.sql (Goose)]
      Y[sqlc.yaml]
    end

    S -- goose up/down --> DB[(PostgreSQL Schema)]
    Q & Y -- sqlc generate --> G[internal/database (generated)]

    App[CLI Runtime]
    App -->|imports| G
    App -->|connects via cfg.DbURL| DB
    Cfg[~/.gatorconfig.json] -->|config.Read| App
    App -->|SetUser| Cfg
```

---

## 7. Summary Table

| Layer | Purpose | Key Files | Tools |
|------|---------|-----------|-------|
| Entrypoint | Wire config, DB, commands; parse args; dispatch | `main.go` | Go stdlib |
| Command Router | Map command names to handlers; execute | `commands.go` | Go stdlib |
| Handlers | Business logic for user ops | `handler_user.go` | SQLC calls |
| Config | Read/write `~/.gatorconfig.json` | `internal/config/config.go`, `configFileName.go` | Go stdlib |
| Database Access | Type-safe queries and models | `internal/database/*` | SQLC |
| Schema | DDL for users table | `sql/schema/001_users.sql` | Goose |
| Queries | SQL definitions for generation | `sql/queries/users.sql` | SQLC |
| Build/Migrate Scripts | Convenience for build/migrate | `makeScript.sh`, `gooser.sh` | Go, Goose |

---

## Appendix: Notable Code References

- `main.go`
  - Reads config: `config.Read()`
  - Connects DB: `sql.Open("postgres", cfg.DbURL)`
  - SQLC binding: `database.New(db)`
  - Registers handlers: `cmds.register("login", handlerLogin)`, `cmds.register("register", handlerRegister)`

- `handler_user.go`
  - Register: uses `database.CreateUserParams` and `uuid.New()` with timestamps
  - Login: uses `db.GetUser(ctx, userName)`, handles `sql.ErrNoRows`
  - Updates config: `s.cfg.SetUser(...)`

- `internal/config`
  - Config file: `~/.gatorconfig.json` with fields `db_url`, `current_user_name`
  - `SetUser` writes back to the same file

- `internal/database` (generated by SQLC)
  - `CreateUser`, `GetUser`, `User` model

- `sqlc.yaml`
  - Engine: `postgresql`
  - Out: `internal/database`

- Goose migration
  - `sql/schema/001_users.sql` with `-- +goose Up/Down`
